/* This is a C99 Sieve of Eratosthenes with a subtle bug in it. It was
 * generated by GitHub/MS Copilot on 2024-02-24, and gently massaged and
 * commented by Mark. Your objective is to fix this implementation by finding
 * the bug, and repairing the source file.
 *
 * To pass this exercise, submit the fixed source file to the submission system
 * to have it checked. To pass, make as few modifications to this source file
 * as possible.
 *
 * The Sieve of Eratosthenes is a prime number-finding algorithm notorious for
 * its extreme memory requirements and poor cache hit rate, but is otherwise
 * effective at identifying prime numbers. Wikipedia has a good description of
 * this algorithm at https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes.
 *
 * A description of the bug: the sieve segmentation faults when run for n=6 on
 * some machines. When there is no segmentation fault, the correct prime
 * numbers are written out nevertheless. */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/* Sieve of Eratosthenes, up to unsigned n greater than 2. Returns a
 * dynamically-allocated array that you will need to free yourself in main,
 * elements are 1 (prime) or 0 (not prime).
 *
 * This function has a bug in it that you need to find. */
unsigned* sieve(size_t const n)
{
    /* Initialise array of n "booleans" to True. */
    unsigned *const primes = malloc(n * sizeof(unsigned));
    if (!primes) {
        perror("malloc");
        return NULL;
    }
    for (size_t i = 0; i < n; i++) {
        primes[i] = 1;
    }

    /* For each number, set multiples of that number to False. */
    primes[0] = primes[1] = 0;
    for (size_t i = 2; i <= sqrt(n); i++) {  /* For each number */
        if (primes[i]) {  /* Efficiency */
            for (size_t j = i * i; j < n; j += i) {
                primes[j] = 0;
            }
        }
    }

    return primes;
}

/* Here is a main function you can use to play with the sieve function, also
 * generated by CoPilot. It doesn't contain the bug, and thus should not be
 * modified.
int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "Usage: %s n\n", argv[0]);
        return 1;
    }

    int n = atoi(argv[1]);
    if (n <= 0) {
        fprintf(stderr, "n must be a positive integer\n");
        return 1;
    }

    unsigned *primes;
    if (!(primes = sieve(n))) return 1;
    for (int i = 0; i < n; i++) if (primes[i]) printf("%d\n", i);

    free(primes);
    return 0;
}
*/
